from decimal import Decimal
from typing import List, Tuple, Iterable, Dict
from csv import DictReader
from io import StringIO

from members.models import Person
from pennotools.core.util import remove_accents, dict_to_xml

import xml.etree.cElementTree as ET
from datetime import datetime

def rabo_sepa(lines: Iterable[Tuple[Person, Decimal]], description: str) -> List[List[str]]:
    """Constructs table in Rabo incasso csv format.

    Format description: https://www.rabobank.nl/images/pdf_formaatbeschrijving_csv_29856100.pdf

    Args:
        lines: Each line specifies a member and the amount.
        description: See format description.

    Returns:
        A 2D table in the correct format, which can directly be saved as csv.
    """
    if len(description) > 35:
        raise ValueError("Description has maximum length of 35.")

    # Create 2D table and add header row
    csv = [['Kenmerk machtiging',
            'Naam betaler',
            'Verkorte naam',
            'Rekeningnummer',
            'Rekeninggroep',
            'Bedrag',
            'Valuta',
            'Categorie',
            'Landcode',
            'Omschrijving 1',
            'Omschrijving 2',
            'Omschrijving 3',
            'Type machtiging',
            'Ondertekend op'
            ]]

    # Add rows
    for p, amount in lines:
        # Check that IBAN and SEPA are set
        if not p.sepa_direct_debit or not p.iban:
            raise ValueError("Person has no SEPA.")

        csv.append([
            p.person_id,  # Kenmerk
            remove_accents("{} {}".format(p.first_name, p.last_name)),
            p.person_id,  # Verkorte naam
            p.iban,
            'Algemeen',  # Rekeninggroep
            f'{amount:.2f}'.replace('.', ','),
            'EUR',  # Valuta
            '',  # Categorie
            p.iban[:2],  # Landcode
            description,
            '',  # Omschrijving 2
            '',  # Omschrijving 3
            'Doorlopend',  # Type machtiging
            p.get_sepa_sign_date().strftime('%d-%m-%Y'),  # Ondertekend op
        ])
    return csv

def parse_csv_dict(lines: str) -> List[Dict]:
    """Parses a string in the RABO sepa csv format. 
    (So a string generated by the function above)"""

    return list(DictReader(StringIO(lines), delimiter=";"))

def rabo_sepa_xml(sepa_transactions: List[Dict]):
    """ Concerts a SEPA csv to a SEPA xml

    The SEPA csv format is no longer supported by the bank, but it kept as an intermediary format (for now), 
    because it is editable by hand
    """
    # Some stuff we'll need
    transactionId = datetime.now().strftime('%m%d%y%H%M%S') # Just to be used as some kind of unique identifier
    now = datetime.now()
    nr_transactions = str(len(sepa_transactions))

    # First, make the XML-nodes for every individual transaction
    controlSum = 0
    transactionnodes = []
    for transaction in sepa_transactions:
        amount = float(transaction['Bedrag'].replace(',', '.'))
        controlSum += amount
        TransactionNodeSkeleton = {
            'PmtId': {
                'EndToEndId': f"{transaction['Kenmerk machtiging']}{transactionId}"
            },
            'InstdAmt': format(amount, '.2f'),
            'DrctDbtTx': {
                'MndtRltdInf': {
                    'MndtId': transaction['Kenmerk machtiging'],
                    'DtOfSgntr': datetime.strptime(transaction['Ondertekend op'].replace('-', '/'), '%d/%m/%Y').strftime('%Y-%m-%d')
                }
            },
            'DbtrAgt': {
                'FinInstnId': {
                    'Othr': {
                        'Id': 'NOTPROVIDED'
                    }
                }
            },
            'Dbtr': {
                'Nm': remove_accents(transaction['Naam betaler'])
            },
            'DbtrAcct': {
                'Id': {
                    'IBAN': transaction['Rekeningnummer']
                }
            },
            'RmtInf': {
                'Ustrd': remove_accents(transaction['Omschrijving 1'])
            }
        }
        transactionNode = dict_to_xml('DrctDbtTxInf', TransactionNodeSkeleton)
        transactionNode.find('InstdAmt').set('Ccy', 'EUR')
        transactionnodes.append(transactionNode )

    # Now, generate the rest of the file
    XmlSkeleton = {
        'CstmrDrctDbtInitn': {
            'GrpHdr': {
                'MsgId': f"Quadrivium {transactionId}", # Sould be unique per transaction
                'CreDtTm': now.strftime('%Y-%m-%dT%H:%M:%S'),
                'NbOfTxs': nr_transactions,
                'CtrlSum': controlSum,
                'InitgPty': {
                    'Nm': 'Eindhovens Studenten Muziekgezelschap Quadrivium' # Shoud maybe not be hardcoded
                }
            },
            'PmtInf': {
                'PmtInfId': f"Qrekening {transactionId}", # Should be unique
                'PmtMtd': 'DD',
                'BtchBookg': 'true',
                'NbOfTxs': nr_transactions,
                'CtrlSum': controlSum,
                'PmtTpInf': {
                    'SvcLvl': {
                        'Cd': 'SEPA'
                    },
                    'LclInstrm': {
                        'Cd': 'CORE'
                    },
                    'SeqTp': 'RCUR' 
                },
                'ReqdColltnDt': '2022-11-18', #TODO Should be user input
                'Cdtr': {
                    'Nm': 'Eindhovens Studenten Muziekgezelschap Quadrivium',
                    'PstlAdr': {
                        # Oh no, dicts don't support identical keys, but xml does!
                        # Luckily, leading numbers are ignored as they are not valid in XML
                        '1AdrLine': 'TU/e Luna de Plint postvaknummer 14 Postbus 513',
                        '2AdrLine': '5600MB Eindhoven'
                    },
                    'CtryOfRes': 'NL'
                },
                'CdtrAcct': {
                    'Id': {
                        'IBAN': 'NL41RABO0367216000'
                    },
                    'Ccy': 'EUR'
                },
                'CdtrAgt': {
                    'FinInstnId': {
                        'BIC': 'RABONL2U'
                    }
                },
                'ChrgBr': 'SLEV',
                'CdtrSchmeId': {
                    'Id': {
                        'PrvtId': {
                            'Othr': {
                                'Id': 'NL48ZZZ402381670000',
                                'SchmeNm': {
                                    'Prtry': 'SEPA'
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Now, set the attibutes and insert the actual transactions
    SepaXmlNode = dict_to_xml('Document', XmlSkeleton)
    SepaXmlNode.set('xmlns', 'urn:iso:std:iso:20022:tech:xsd:pain.008.001.02')
    SepaXmlNode.set('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
    PaymentInfoNode = SepaXmlNode.find(".//PmtInf")
    for node in transactionnodes:
        PaymentInfoNode.append(node)
    
    # ... and done
    return ET.tostring(SepaXmlNode, encoding='utf-8')
